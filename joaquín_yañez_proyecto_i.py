# -*- coding: utf-8 -*-
"""Joaquín Yañez Proyecto I.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qa3FTwf8hKvnq6Pre_y9H4PIHSwU_oBf

Importación e instalacion de librerías:
"""

from PIL import Image, ImageDraw, ImageStat, ImageChops
import requests
from IPython.display import Image as IPImage
from IPython.display import display
import random
import matplotlib.pyplot as plt
import numpy as np

"""Leer, guardar, mostrar imágenes:"""

# Para leer images podemos usar Pillow, el cual nos proporciona una serie de métodos para obtener y manipular la
# información de la imagen seleccionada, incluyendo cambiar el tamaño, recortar la imagen, modificar pixeles.
# Fuentes: https://pillow.readthedocs.io/en/stable/reference/Image.html

img = Image.open(requests.get('https://graffica.info/wp-content/uploads/2017/07/logo-nasa-fondo-oscuro.jpg', stream=True).raw)
print(img)

# Para mostrar la imagen podemos usar IPython.
# Fuentes: https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html
# https://stackoverflow.com/questions/49478791/how-can-i-open-images-in-a-google-colaboratory-notebook-cell-from-uploaded-png-f

display(IPImage('https://graffica.info/wp-content/uploads/2017/07/logo-nasa-fondo-oscuro.jpg'))

# Para guardar imágenes Pillow nos proporciona el método save, que nos permite modificar la extensión del archivo.
# Fuentes: https://pillow.readthedocs.io/en/stable/reference/Image.html
# https://www.geeksforgeeks.org/python-pil-image-save-method/

img.save('test.jpg')

"""Para manejar colores y transparencias"""

# Con el módulo Image de Pillow podemos usar el método getdata para obtener y putdata para modificar la información pixel a pixel de la imagen.
# Fuente: https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.getdata

# Creamos un lienzo negro para modificarlo
img = Image.new('RGBA', (125,125), (0,0,0,255))
display(img)

# Obtenemos los datos de los píxeles
img_data = img.getdata()
print(list(img_data))

# Creamos una lista en la que guardaremos los nuevos colores de la imagen.
new_image_data = []

for pixel in img_data:
  new_image_data = new_image_data + [(pixel[0]+30, pixel[1]+50, pixel[2]+80, pixel[3]-99)]
print(new_image_data)

# Modificamos la imagen pasando una secuencia de pixeles al metodo putdata
img.putdata(new_image_data)

# Mostramos la imagen
display(img)

"""Crear imagenes dibujando polígonos:"""

# Para crear imágenes usando polígonos podemos usar el módulo Image en conjunto con el de ImageDraw de Pillow.
# Fuentes: https://pillow.readthedocs.io/en/stable/reference/Image.html
# https://pillow.readthedocs.io/en/stable/reference/ImageDraw.html

#Creamos el lienzo
img = Image.new('RGBA', (125,125), (255,255,255,255))
#Creamos el polígono
poly = Image.new('RGBA', (125,125))
pdraw = ImageDraw.Draw(poly)
pdraw.polygon([(50,28),(120,240),(128,157),(15,128)],
              fill=(0,255,255,180),outline=(255,255,255,255))
#Agregamos el polígono al lienzo
img.paste(poly,mask=poly)

# Si quisieramos dibujar varios usariamos un for loop y la librería random
for i in range(40):
  poly = Image.new('RGBA', (250,250))
  pdraw = ImageDraw.Draw(poly)
  pdraw.polygon([(random.randint(-15,265),random.randint(-15,265)),(random.randint(-15,265),random.randint(-15,265)),(random.randint(-15,265),random.randint(-15,265)),(random.randint(-15,265),random.randint(-15,265))],
              fill=(random.randint(0,255),random.randint(0,255),random.randint(0,255),random.randint(0,300)),outline=(255,255,255,1))
  img.paste(poly,mask=poly)


display(img)

"""Comparar dos imágenes y calcular el fitness:"""

# Para comparar dos imágenes pixel a pixel, usamos ImageChops.difference que toma dos imagenes y retorna un objeto Image que contiene
# el valor absoluto de la diferencia pixel a pixel. Luego se suma todos los valores de cada canal y se divide entre el maximo valor que
# podria tomar (255*cantidad_de_pixeles), esto nos dara la diferencia en cada canal. Al restarle la diferencia de cada canal a 1 nos va a
# quedar la similitud en cada canal. Finalmente para el fitness sumamos los 3 valores y lo dividimos entre 3
# Fuentes: https://pillow.readthedocs.io/en/stable/reference/ImageStat.html
# https://pillow.readthedocs.io/en/stable/reference/Image.html
# https://pillow.readthedocs.io/en/stable/reference/ImageChops.html 

#Las imagenes deben ser del mismo tamaño
img_a = Image.open(requests.get('https://graffica.info/wp-content/uploads/2017/07/logo-nasa-fondo-oscuro.jpg', stream=True).raw)
img_a = img_a.resize((125,125))
img_b = Image.open(requests.get('https://graffica.info/wp-content/uploads/2017/08/LogoNasaSpotB-1200x675.jpg', stream=True).raw)
img_b = img_b.resize((125,125))

# Generamos una imagen diferencia y con getdata la convertimos en una lista que podamos manipular.
# Esta contiene la información de todos los pixeles de la imagen
diff_matrix = ImageChops.difference(img_a,img_b)
diff_list = list(diff_matrix.getdata())

# La imagen tendrá tantos pixeles como elementos tenga la lista
total_pixels = len(diff_list)

# Los valores de los canales rgb de cada pixel en la lista de diferencia contiene 
# la diferencia absoluta entre pixeles por lo tanto la suma de todos los valores en cada canal
# divididos entre el valor maximo que puede tomar cada canal nos dara la proporcion del error
# entre las imagenes
total_red, total_green, total_blue = 0, 0, 0
max_red, max_green, max_blue = 255*total_pixels, 255*total_pixels, 255*total_pixels

for pixel in diff_list:
  total_red = total_red + pixel[0]
  total_green = total_green + pixel[1]
  total_blue = total_blue + pixel[2]

# Como buscamos medir la similitud esto viene dado por 1 menos la proporcion de error
fitness_red_channel = 1-total_red/max_red
fitness_green_channel = 1-total_green/max_green
fitness_blue_channel = 1-total_green/max_green

# Mostramos el fitness con solo dos decimales
fitness = float("{:.2f}".format((fitness_red_channel + fitness_green_channel + fitness_blue_channel) / 3))

print(fitness)

"""Hacer gráficos:"""

# Para los gráficos usaremos matplotlib.
# Fuentes: https://matplotlib.org/stable/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py
# https://matplotlib.org/stable/tutorials/introductory/pyplot.html#sphx-glr-tutorials-introductory-pyplot-py

plt.plot([1, 2, 3, 4], [16, 9, 4, 1], 'bo')
plt.axis([0, 6, 0, 20])
plt.show()

"""Implementación de funciones:

Crear las estructuras de individuos y de población.
"""

# En este caso sabemos que nuestro modelo es la imagen objetivo, un individuo se divide 
# en el genotipo, una lista con los polígonos que se usarán para crear la imagen (250x250), y el fenotipo
# la imagen que lo representa. Por otro lado, la población es una secuencia (lista) de individuos.

def crear_individuo() -> list:
  """ Programa que genera un individuo.

      Args:

      Returns: Una lista que representa el genotipo de un individuo.
  """

  individual = []

  # El individuo esta compuesto por 3 coordenadas para el polígono (los cuales permiten un poco de offset para representar mejor la imagen)
  # y una tupla rgba para que se permita transparencia en los polígonos.
  for i in range(70):
    random_pos_x = (random.randint(-15,265), random.randint(-15,265))
    random_pos_y = (random.randint(-15,265), random.randint(-15,265))
    random_pos_z = (random.randint(-15,265), random.randint(-15,265))
    random_channel_r = random.randint(0,255)
    random_channel_g = random.randint(0,255)
    random_channel_b = random.randint(0,255)
    random_channel_a = random.randint(0,255)
    poly = [[random_pos_x, random_pos_y, random_pos_z], (random_channel_r, random_channel_g, random_channel_b, random_channel_a)]
    individual = individual + [poly]
  
  try:
    assert isinstance(individual, list)
  except:
    print('Ha ocurrido un error en el proceso')

  return individual

def crear_poblacion(n) -> list: 
  """ Programa que crea una población de n individuos

      Args:
      n:int

      Returns:
      Una lista que representa la población
  """

  try: 
    assert isinstance(n, int)
    assert n>2
  except:
    print('n debe ser un entero mayor que 2')

  poblacion = []

  # Crea n individuos
  for i in range(n):
    individuo = crear_individuo()
    poblacion = poblacion + [individuo]

  try:
    assert isinstance(poblacion, list)
  except:
    print('Ha ocurrido un error en el proceso')
  
  return poblacion

print(crear_individuo())
print(crear_poblacion(3))

"""Crear individuos aleatorios y mostrar la imagen correspondiente."""

def show_image() -> None:
  """ Programa que genera una lista de individuos aleatorios y muestra la imagen de cada uno
  """

  poblacion = crear_poblacion(10)

  for individuo in poblacion:
    #Creamos el lienzo
    img = Image.new('RGBA', (125,125), (255,255,255,255))
    for poligono in individuo:
      #Creamos el polígono
      poly = Image.new('RGBA', (125,125))
      pdraw = ImageDraw.Draw(poly)
      pdraw.polygon(poligono[0], fill=poligono[1])
      #Agregamos el polígono al lienzo
      img.paste(poly,mask=poly)
    display(img)
    print()

print(show_image())

"""Implementar el operador de selección."""

# Para la selección usaremos Stochastic Universal Sampling que es una pequeña variación de roulette wheel
# donde la diferencia recae en que todos los individuos se seleccion de una vez por medio de varios apuntadores
# equidistantes.
# Fuente: https://stackoverflow.com/questions/22749132/stochastic-universal-sampling-ga-in-python

# Al igual que en roulette wheel creamos la ruleta y pesamos a cada individuo por su fitness.
def makeWheel(population):
    """ Crea la ruleta para el operador de selección, aplica para Roulette Wheel y Stochastic Universal Sampling

        Args: population

        Returns: wheel
    """
    wheel = []
    total = sum(fitness(p) for p in population)
    top = 0
    for p in population:
        f = fitness(p)/total
        wheel.append((top, top+f, p))
        top += f
    return wheel

# Implementación de búsqueda binaria.
def binSearch(wheel, num):
    """ Función de búsqueda binaria

        Args: wheel,num

        Returns: answer
    """
    mid = len(wheel)//2
    low, high, answer = wheel[mid]
    if low<=num<=high:
        return answer
    elif high < num:
        return binSearch(wheel[mid+1:], num)
    else:
        return binSearch(wheel[:mid], num)

# Implementamos el operador de selección donde la distancia entre los punteros viene dada por
# 1/N siendo N la cantidad individuos que buscamos seleccionar.
def select(wheel, N):
    """ Operador de selección con stochastic universal sampling

        Args: wheel,num

        Returns: answer
    """
    stepSize = 1.0/N
    selected = []
    r = random.random()
    selected.append(binSearch(wheel, r))
    while len(answer) < N:
        r += stepSize
        if r>1:
            r %= 1
        selected.append(binSearch(wheel, r))
    return selected

"""Implementar el operador crossover."""

# En este caso implementaremos multi-point crossover, que consiste en generar múltiples puntos
# para intercambiar información entre los padres y así formar los hijos.
# Fuentes: https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_crossover.htm
# https://medium.com/@samiranbera_66038/crossover-operator-the-heart-of-genetic-algorithm-6c0fdcb405c0

# Como multi-point crossover es una variación de single-point crossover con varios puntos de intercambio primero
# implementemos esta función

def single_point_crossover(A: list, B: list, x: int) -> list:
  # El hijo A tendra la información de A a la izquierda de x y de B a la derecha de x
  # El hijo B tendra la información de B a la izquierda de x y de A a la derecha de x
  A_child = np.append(A[:x], B[x:])
  B_child = np.append(B[:x], A[x:])
  return A_child, B_child

def multi_point_crossover(A: list, B: list, x: list) -> list:
  # Aplicamos la función single_point_crossover en varios puntos de x
  for point in x:
    A, B = single_point_crossover(A,B,point)
  return A, B

A = np.array([1,2,3,4,5,6,7,8,9])
B = np.array([9,8,7,6,5,4,3,2,1])
x = np.array([2,4])

print(multi_point_crossover(A,B,x))

"""Implementar el operador de mutación."""

def mutation(individual: list) -> list:
  """ Operador que toma un individuo y muta el 10% de sus características.

      Args:
      individualt: list

      Returns:
      Una lista que representa el individuo
  """

  try:
    assert isinstance(individual, list)
  except:
    print('La poblacion debe ser de tipo lista')

  # Para un 10% de las caracteristicas del individuo se cambian las coordenadas
  # y el color del polígono.
  for i in range(7):
    index = random.randint(0,len(individual)-1)
    random_pos_x = (random.randint(-15,265), random.randint(-15,265))
    random_pos_y = (random.randint(-15,265), random.randint(-15,265))
    random_pos_z = (random.randint(-15,265), random.randint(-15,265))
    random_channel_r = random.randint(0,255)
    random_channel_g = random.randint(0,255)
    random_channel_b = random.randint(0,255)
    random_channel_a = random.randint(0,255)
    new_value = [[random_pos_x, random_pos_y, random_pos_z], (random_channel_r, random_channel_g, random_channel_b, random_channel_a)]
    individual[index] = new_value

  try:
    assert isinstance(individual, list)
  except:
    print('Algo ha salido mal al realizar los cambios')
  
  return individual

print(mutation(crear_individuo()))

"""Para la próxima entrega resta mejorar la documentación, implementar pure-elitism a 1 o 2 individuos antes del proceso de selección"""